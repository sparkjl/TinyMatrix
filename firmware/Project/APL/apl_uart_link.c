#include "includes.h"

//#define CRC16_BUYPASS      1
#define CRC16_MODBUS       2

#ifdef CRC16_BUYPASS
/* CRC-16/BUYPASS width=16 poly=0x8005 init=0x0000 refin=false refout=false xorout=0x0000 */

static const uint16_t crc16_table[256] = {
0x0000,0x8005,0x800F,0x000A,0x801B,0x001E,0x0014,0x8011,
0x8033,0x0036,0x003C,0x8039,0x0028,0x802D,0x8027,0x0022,
0x8063,0x0066,0x006C,0x8069,0x0078,0x807D,0x8077,0x0072,
0x0050,0x8055,0x805F,0x005A,0x804B,0x004E,0x0044,0x8041,
0x80C3,0x00C6,0x00CC,0x80C9,0x00D8,0x80DD,0x80D7,0x00D2,
0x00F0,0x80F5,0x80FF,0x00FA,0x80EB,0x00EE,0x00E4,0x80E1,
0x00A0,0x80A5,0x80AF,0x00AA,0x80BB,0x00BE,0x00B4,0x80B1,
0x8093,0x0096,0x009C,0x8099,0x0088,0x808D,0x8087,0x0082,
0x8183,0x0186,0x018C,0x8189,0x0198,0x819D,0x8197,0x0192,
0x01B0,0x81B5,0x81BF,0x01BA,0x81AB,0x01AE,0x01A4,0x81A1,
0x01E0,0x81E5,0x81EF,0x01EA,0x81FB,0x01FE,0x01F4,0x81F1,
0x81D3,0x01D6,0x01DC,0x81D9,0x01C8,0x81CD,0x81C7,0x01C2,
0x0140,0x8145,0x814F,0x014A,0x815B,0x015E,0x0154,0x8151,
0x8173,0x0176,0x017C,0x8179,0x0168,0x816D,0x8167,0x0162,
0x8123,0x0126,0x012C,0x8129,0x0138,0x813D,0x8137,0x0132,
0x0110,0x8115,0x811F,0x011A,0x810B,0x010E,0x0104,0x8101,
0x8303,0x0306,0x030C,0x8309,0x0318,0x831D,0x8317,0x0312,
0x0330,0x8335,0x833F,0x033A,0x832B,0x032E,0x0324,0x8321,
0x0360,0x8365,0x836F,0x036A,0x837B,0x037E,0x0374,0x8371,
0x8353,0x0356,0x035C,0x8359,0x0348,0x834D,0x8347,0x0342,
0x03C0,0x83C5,0x83CF,0x03CA,0x83DB,0x03DE,0x03D4,0x83D1,
0x83F3,0x03F6,0x03FC,0x83F9,0x03E8,0x83ED,0x83E7,0x03E2,
0x83A3,0x03A6,0x03AC,0x83A9,0x03B8,0x83BD,0x83B7,0x03B2,
0x0390,0x8395,0x839F,0x039A,0x838B,0x038E,0x0384,0x8381,
0x0280,0x8285,0x828F,0x028A,0x829B,0x029E,0x0294,0x8291,
0x82B3,0x02B6,0x02BC,0x82B9,0x02A8,0x82AD,0x82A7,0x02A2,
0x82E3,0x02E6,0x02EC,0x82E9,0x02F8,0x82FD,0x82F7,0x02F2,
0x02D0,0x82D5,0x82DF,0x02DA,0x82CB,0x02CE,0x02C4,0x82C1,
0x8243,0x0246,0x024C,0x8249,0x0258,0x825D,0x8257,0x0252,
0x0270,0x8275,0x827F,0x027A,0x826B,0x026E,0x0264,0x8261,
0x0220,0x8225,0x822F,0x022A,0x823B,0x023E,0x0234,0x8231,
0x8213,0x0216,0x021C,0x8219,0x0208,0x820D,0x8207,0x0202
};

uint16_t crc16_create(uint8_t *p_data, uint16_t len)
{
  uint8_t temp = 0;
  uint16_t crc_code = 0;

  while(len--)
  {
    temp = (uint8_t)(crc_code >> 8);
    crc_code <<= 8;
    crc_code ^= crc16_table[temp ^ *p_data];
    p_data++;
  }

  return crc_code;
}

void crc16_fill(uint8_t *p_data, uint16_t len)
{
  uint16_t crc_code = 0;

  if(len < 2)
    return;

  crc_code = crc16_create(p_data, len-2);

  p_data[len-1] = crc_code & 0xff;
  p_data[len-2] = (crc_code >> 8) & 0xff;
}

#elif CRC16_MODBUS
/* CRC-16/MODBUS width=16 poly=0x8005 init=0xffff refin=true refout=true xorout=0x0000 */

static const uint16_t crc16_table[256] = {
0x0000,0xc0c1,0xc181,0x0140,0xc301,0x03c0,0x0280,0xc241,
0xc601,0x06c0,0x0780,0xc741,0x0500,0xc5c1,0xc481,0x0440,
0xcc01,0x0cc0,0x0d80,0xcd41,0x0f00,0xcfc1,0xce81,0x0e40,
0x0a00,0xcac1,0xcb81,0x0b40,0xc901,0x09c0,0x0880,0xc841,
0xd801,0x18c0,0x1980,0xd941,0x1b00,0xdbc1,0xda81,0x1a40,
0x1e00,0xdec1,0xdf81,0x1f40,0xdd01,0x1dc0,0x1c80,0xdc41,
0x1400,0xd4c1,0xd581,0x1540,0xd701,0x17c0,0x1680,0xd641,
0xd201,0x12c0,0x1380,0xd341,0x1100,0xd1c1,0xd081,0x1040,
0xf001,0x30c0,0x3180,0xf141,0x3300,0xf3c1,0xf281,0x3240,
0x3600,0xf6c1,0xf781,0x3740,0xf501,0x35c0,0x3480,0xf441,
0x3c00,0xfcc1,0xfd81,0x3d40,0xff01,0x3fc0,0x3e80,0xfe41,
0xfa01,0x3ac0,0x3b80,0xfb41,0x3900,0xf9c1,0xf881,0x3840,
0x2800,0xe8c1,0xe981,0x2940,0xeb01,0x2bc0,0x2a80,0xea41,
0xee01,0x2ec0,0x2f80,0xef41,0x2d00,0xedc1,0xec81,0x2c40,
0xe401,0x24c0,0x2580,0xe541,0x2700,0xe7c1,0xe681,0x2640,
0x2200,0xe2c1,0xe381,0x2340,0xe101,0x21c0,0x2080,0xe041,
0xa001,0x60c0,0x6180,0xa141,0x6300,0xa3c1,0xa281,0x6240,
0x6600,0xa6c1,0xa781,0x6740,0xa501,0x65c0,0x6480,0xa441,
0x6c00,0xacc1,0xad81,0x6d40,0xaf01,0x6fc0,0x6e80,0xae41,
0xaa01,0x6ac0,0x6b80,0xab41,0x6900,0xa9c1,0xa881,0x6840,
0x7800,0xb8c1,0xb981,0x7940,0xbb01,0x7bc0,0x7a80,0xba41,
0xbe01,0x7ec0,0x7f80,0xbf41,0x7d00,0xbdc1,0xbc81,0x7c40,
0xb401,0x74c0,0x7580,0xb541,0x7700,0xb7c1,0xb681,0x7640,
0x7200,0xb2c1,0xb381,0x7340,0xb101,0x71c0,0x7080,0xb041,
0x5000,0x90c1,0x9181,0x5140,0x9301,0x53c0,0x5280,0x9241,
0x9601,0x56c0,0x5780,0x9741,0x5500,0x95c1,0x9481,0x5440,
0x9c01,0x5cc0,0x5d80,0x9d41,0x5f00,0x9fc1,0x9e81,0x5e40,
0x5a00,0x9ac1,0x9b81,0x5b40,0x9901,0x59c0,0x5880,0x9841,
0x8801,0x48c0,0x4980,0x8941,0x4b00,0x8bc1,0x8a81,0x4a40,
0x4e00,0x8ec1,0x8f81,0x4f40,0x8d01,0x4dc0,0x4c80,0x8c41,
0x4400,0x84c1,0x8581,0x4540,0x8701,0x47c0,0x4680,0x8641,
0x8201,0x42c0,0x4380,0x8341,0x4100,0x81c1,0x8081,0x4040
};

uint16_t crc16_create(uint8_t *p_data, uint16_t len)
{
  uint8_t temp = 0;
  uint16_t crc_code = 0xffff;

  while(len--)
  {
    temp = (uint8_t)(crc_code & 0xff);
    crc_code >>= 8;
    crc_code ^= crc16_table[temp ^ *p_data];
    p_data++;
  }

  return crc_code;
}

void crc16_fill(uint8_t *p_data, uint16_t len)
{
  uint16_t crc_code = 0;

  if(len < 2)
    return;

  crc_code = crc16_create(p_data, len-2);

  p_data[len-1] = (crc_code >> 8) & 0xff;
  p_data[len-2] = crc_code & 0xff;
}

#else

#endif


UartLink_HandleTypeDef ulink;

uint8_t apl_ulink_handle(void)
{
  uint8_t status = 0;
  uint16_t crc_code = 0;

  if(uart1.rx_state == UART_OVER)
  {

    ulink.addr = uart1.rx_buff[0];
    ulink.func = uart1.rx_buff[1];
    ulink.tick = uart1.rx_buff[2];
    ulink.length = uart1.rx_buff[3];

    for(uint16_t i=0; i<ulink.length; i++)
    {
      ulink.data[i] = uart1.rx_buff[4+i];
    }

    ulink.crc16[0] = uart1.rx_buff[ulink.length+4];
    ulink.crc16[1] = uart1.rx_buff[ulink.length+5];

    api_uart_rx_start(&uart1);

    crc_code = crc16_create((uint8_t *)&ulink, ulink.length+4);

    if((ulink.crc16[0] == (crc_code & 0xff)) && (ulink.crc16[1] == (crc_code >> 8)))
    {
      status = 1;
      if(ulink.addr == 0x01)
      {
        status = 2;
        switch(ulink.func)
        {
          case 0:
            break;

          case 1:
            apl_font_upgrade(ulink.data, ulink.length);
            break;

          case 2:
            strcpy((char*)sys_data.font_text[0], (char*)ulink.data);
            break;

          default:
            break;
        }

        if(ulink.func == 1)
        {
          uart1.tx_buff[0] = ulink.addr;
          uart1.tx_buff[1] = ulink.func;
          uart1.tx_buff[2] = ulink.tick;
          uart1.tx_buff[3] = ulink.length = 0;

          crc16_fill(uart1.tx_buff, 6);
          api_uart_tx_start(&uart1, uart1.tx_buff, 6);
        }
        else
        {
          uart1.tx_buff[0] = ulink.addr;
          uart1.tx_buff[1] = ulink.func;
          uart1.tx_buff[2] = ulink.tick;
          uart1.tx_buff[3] = ulink.length;

          for(uint16_t i=0; i<ulink.length; i++)
          {
            uart1.tx_buff[4+i] = ulink.data[i];
          }

          crc16_fill(uart1.tx_buff, ulink.length+6);
          api_uart_tx_start(&uart1, uart1.tx_buff, ulink.length+6);
        }
      }
    }
  }

  return status;
}

